Свой пример я запускала с двумя сборщиками мусора: 
G1 и Parallel Collector 
(VM опции -XX:+UseG1GC и -XX:+UseParallelGC соответственно)

При G1 пример крашнулся через 5 минут 32 секунды, тогда как Parallel Collector 
продолжал работать и после 30 минут после запуска.
В случае использования Parallel Collector, если я сильно уменьшала случаи "засыпания", 
меняя команду   if (i%50==0)   Thread.sleep(1);
на              if (i%1000==0)   Thread.sleep(1);
  только теперь ресурсов стало не хватать и стал происходить выход за пределы памяти.
  
  Считаю, что это происходит потому, что Parallel Collector нацелен на работу
  с данными при максимальной пропускной способности, а также в процессе сборки мусора
  он паралельно работает со старым и новым поколениями данных, собирая данные в
  несколько потоков. Поэтому для него "засыпания" основного потока требуется гораздо
  реже.
  Тогда как G1 нацелен на уменьшение ресурсов, отдаваемого сборщику, за счет 
  Concurrent-механизма, что не замедляет процесс выполнения самой программы 
  (программа ведет себя более предсказуемо), но ресурсы гораздо быстрее растрачиваются.
  Поэтому G1 работает некорректно при редком "засыпании" основного потока.
   
  
   
  
          
